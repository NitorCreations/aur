<html>
<head>
<title>Nitor Business Card Augmented Reality Demo</title>
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
<style>
html,body {
  margin: 0;
  padding: 0;
  width: 100%;
  text-align: center;
  overflow-x: hidden;
}
.portrait canvas {
  transform-origin: 0 0;
  transform: rotate(-90deg) translateX(-100%);
}
.desktop canvas {
  height: 100vh !important;
  width: 100vw !important;
  object-fit: cover;

  /* this mirrors the image */
  /* transform: scale(-1, 1); */
}
</style>
</head>
<body>

<!--
<p>On Chrome on Android, tap the screen to start playing video stream.</p>
<script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
-->

<script src="/utils.js"></script>
<script src="./deps/artoolkit.debug.js"></script>
<script src="./deps/artoolkit.api.js"></script>
<script async src="./deps/three.min.js"></script>
<script async src="./deps/artoolkit.three.js"></script>

<script>

var person, persons, hashPersonName, font;

window.start = (person, videoParams) => {
  ARController.getUserMediaThreeScene({
    width: window.innerWidth,
    height: window.innerHeight,
    cameraParam: 'data/camera_para.dat',
    deviceId: videoParams.deviceId,
  onSuccess: function(arScene, arController, arCamera) {
    const clickMap = {}
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    arScene.camera.isPerspectiveCamera = true
    document.body.className = arController.orientation;
    arController.setPatternDetectionMode(artoolkit.AR_MATRIX_CODE_DETECTION);

    var renderer = new THREE.WebGLRenderer({antialias: true});
    if (arController.orientation === 'portrait') {
      var w = (window.innerWidth / arController.videoHeight) * arController.videoWidth;
      var h = window.innerWidth;
      renderer.setSize(w, h);
      renderer.domElement.style.paddingBottom = (w-h) + 'px';
    } else {
      if (/Android|mobile|iPad|iPhone/i.test(navigator.userAgent)) {
        renderer.setSize(window.innerWidth, (window.innerWidth / arController.videoWidth) * arController.videoHeight);
      } else {
        renderer.setSize(arController.videoWidth, arController.videoHeight);
        document.body.className += ' desktop';
      }
    }

    document.body.insertBefore(renderer.domElement, document.body.firstChild);

    // See /doc/patterns/Matrix code 3x3 (72dpi)/20.png
    var markerRoot = arController.createThreeBarcodeMarker(20);

    if (!person.model) {
      console.log('using debug model')
      person.model = new THREE.Mesh(
        new THREE.SphereGeometry(0.5, 8, 8),
        new THREE.MeshNormalMaterial()
      );
      person.model.material.shading = THREE.FlatShading;
    }

    var zoomTarget = 1; // how far is the zoom
    var zoomFactor = 0; // how quick is the animation

    // zoom in/out on the model
    clickMap[person.model.uuid] = () => {
      zoomTarget = person.zoomed ? 1 : 2
      zoomFactor = person.zoomed ? -0.1 : 0.1
      person.zoomed = !person.zoomed
    }
    person.model.position.z = 1;
    markerRoot.add(person.model);

    if (person.twitter) {
      makeCube({
        path: '/twitter.png',
        y: 0.5
      }).then(twitter => {
        clickMap[twitter.uuid] = () => window.open(`https://twitter.com/${person.twitter}`)
        markerRoot.add(twitter)
      })
    }

    if (person.linkedIn) {
      makeCube({
        path: '/linkedIn.png',
        y: -0.5
      }).then(linkedIn => {
        clickMap[linkedIn.uuid] = () => window.open(person.linkedIn)
        markerRoot.add(linkedIn)
      })
    }

    const nameMesh = makeText(person.name)
    nameMesh.position.set( -1, -1.5, 1 );
    markerRoot.add(nameMesh);

    arScene.scene.add(markerRoot);

    renderer.domElement.addEventListener('click', ev => {
      ev.preventDefault();

      mouse.x = ( ev.clientX / renderer.domElement.clientWidth ) * 2 - 1;
      mouse.y = -( ev.clientY / renderer.domElement.clientHeight ) * 2 + 1;

      raycaster.setFromCamera( mouse, arScene.camera );
      var intersects = raycaster.intersectObjects( arScene.scene.children, true );

      intersects.forEach(intersect => {
        const click = clickMap[intersect.object.uuid] || utils.noop
        click(intersect)
      })
    }, false);

    const applyAnimations = () => {
      const roundedScale = Math.round( person.model.scale.x * 10 ) / 10;
      if (roundedScale !== zoomTarget) {
        person.model.scale.set(
          person.model.scale.x += zoomFactor,
          person.model.scale.y += zoomFactor,
          person.model.scale.z += zoomFactor
        )
      }
    }

    const tick = () => {
      arScene.process();
      arScene.renderOn(renderer);
      applyAnimations();
      requestAnimationFrame(tick);
    };

    tick();
  }});
};

if (window.location.hash) {
  const hashFile = `/${utils.getHash()}.txt`
  fetch(hashFile)
    .then(resp => resp.status === 200 && resp.text())
    .then(resp => hashPersonName = resp && resp.trim())
}

fetch('/persons.json')
  .then(resp => resp.json())
  .then(resp => {
    persons = resp
    person = persons[utils.getParameterByName('p')] || { image: '/nitor.png' }

    if (hashPersonName && person.name === hashPersonName) {
      person.hash = utils.getHash()
      localStorage.setItem(person.hash, person.name)
    }

    const material$ = utils.loadTexture(person.texture || person.image)
    const geometry$ = person.mesh ? utils.loadGeometry(person.mesh) : makePlane()
    const videoParams$ = utils.getVideoParams()

    utils.loadFont('/helvetiker_regular.typeface.json')
      .then(resp => font = resp)

    Promise.all([ material$, geometry$, videoParams$ ])
      .then(([ material, geometry, videoParams ]) => {
        person.model = new THREE.Mesh( geometry, material );
        window.start(person, videoParams)
      })
  })

function makeText(text) {
  const opts = {
    font: font,
    size: 0.25,
    height: 0,
    curveSegments: 1,
    bevelEnabled: false
  }

  return new THREE.Mesh(
    new THREE.TextGeometry(text, opts),
    new THREE.MeshPhongMaterial({ color: 0x000000 })
  );
}

function makePlane(width = 1, height = 1) {
  const plane = new THREE.PlaneGeometry( width, height, 160, 160 )
  return Promise.resolve(plane)
}

function makeCube(options) {
  const opts = Object.assign({
    width: 0.5,
    height: 0.5,
    depth: 0.5,
    x: 1,
    y: 1,
    z: 0.5
  }, options)

  return utils.loadTexture(opts.path).then(material => {
    const cube = new THREE.Mesh(
      new THREE.CubeGeometry( opts.width, opts.height, opts.depth ),
      material
    );
    cube.position.x = opts.x;
    cube.position.y = opts.y;
    cube.position.z = opts.z;

    return cube;
  })
}

</script>

</body>
</html>
